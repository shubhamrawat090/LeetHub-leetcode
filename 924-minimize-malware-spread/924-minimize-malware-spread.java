class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        parent = new int[graph.length];
        size = new int[graph.length];
        
        for(int i=0; i<graph.length; i++) {
            parent[i] = i;
            size[i] = 1;
        }
        
        for(int i=0; i<graph.length; i++) {
            for(int j=0; j<graph.length; j++) {
                if(i!=j && graph[i][j] == 1) {
                    unionHelper(i, j);
                }
            }
        }
        
        //traverse initial[] and find no. of infected in each sets
        int[] countMalwareMap = new int[graph.length];
        for(int i: initial) {
            //store no. of infected inside leader of the set to identify the set
            int leaderI = find(i);
            countMalwareMap[leaderI]++;
        }
        
        int maxInfectedVtx = -1, maxInfectedSize = 0;
        for(int i: initial) {
            int leaderI = find(i);
            //only 1 infected in the entire set can be cured as we can cure only 1 vertex which could save the set
            if(countMalwareMap[leaderI] == 1) {
                if(maxInfectedVtx == -1) {
                    maxInfectedVtx = i;
                    maxInfectedSize = size[leaderI];
                }
                //find the set with highest size
                else if(size[leaderI] > maxInfectedSize) {
                    maxInfectedVtx = i;
                    maxInfectedSize = size[leaderI];
                } 
                //for equal size sets with ONLY 1 infected take the lower value vtx or the vtx that appears first in graph
                else if(size[leaderI] == maxInfectedSize) {
                    if(i<maxInfectedVtx) {
                        maxInfectedVtx = i;
                        maxInfectedSize = size[leaderI];
                    }
                }
            }
        }
        
        //if answer cannot be found then return the smallest value from the initial[]
        if(maxInfectedVtx == -1) {
            int smallestVtx = Integer.MAX_VALUE;
            for(int i: initial) {
                smallestVtx = Math.min(smallestVtx, i);
            }
            
            maxInfectedVtx = smallestVtx;
        }
        return maxInfectedVtx;
    }
    
    //We are doing UNION on the basis of size and not rank i.e. smaller size reports to larger size set
    int[] parent;
    int[] size;
    
    int find(int x) {
        if(parent[x] == x) {
            return x;
        } else {
            parent[x] = find(parent[x]);
            return parent[x];
        }
    }
    
    void unionHelper(int x, int y) {
        int xl = find(x);
        int yl = find(y);
        
        if(size[xl] < size[yl]) {
            parent[xl] = yl;
            size[yl] += size[xl];
        } else {
            parent[yl] = xl;
            size[xl] += size[yl];
        }
    }
}